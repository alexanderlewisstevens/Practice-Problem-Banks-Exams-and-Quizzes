\documentclass[12pt]{article}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\geometry{margin=1in}
\begin{document}

\title{Quiz 5 Bank}
\author{Prepared by Alex Stevens}
\date{}
\maketitle

\section*{Problem 1: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(arr):
    if len(arr) == 0:
        return 0
    if len(arr) == 1:
        return 1 if arr[0] > 0 else 0
    mid = len(arr) // 2
    left = process_data(arr[:mid])
    right = process_data(arr[mid:])
    return left + right
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function.

\vspace{2em}

\section*{Problem 3: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(arr):
    if len(arr) < 3:
        return arr
    a = process_data(arr[:len(arr)//2])
    b = process_data(arr[len(arr)//2:len(arr)//2 + 1])
    c = process_data(arr[len(arr)//2 + 1:])
    return a + b + c
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function.

\vspace{2em}

\section*{Problem 4: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(arr):
    if len(arr) <= 2:
        return arr
    mid = len(arr) // 2
    left = process_data(arr[:mid])
    right = process_data(arr[mid:])
    return left + right
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function.

\vspace{2em}

\section*{Problem 5: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(arr):
    if len(arr) <= 1:
        return arr
    third = len(arr) // 3
    a = process_data(arr[:third])
    b = process_data(arr[third:2*third])
    c = process_data(arr[2*third:])
    return a + b + c
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function.

\vspace{2em}

\section*{Problem 6: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(points):
    if len(points) <= 3:
        return brute_force(points)
    mid = len(points) // 2
    left = process_data(points[:mid])
    right = process_data(points[mid:])
    cross = find_cross_pairs(points, mid)
    return left + right + cross
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function. Assume that $find_cross_pairs$ runs in $O(n)$ time.

\vspace{2em}

\section*{Problem 8: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(arr):
    if len(arr) <= 1:
        return arr[0]
    mid = len(arr) // 2
    left = process_data(arr[:mid])
    right = process_data(arr[mid:])
    return 0.7 * left + 0.3 * right
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function.

\vspace{2em}

\section*{Problem 9: Divide and Conquer Time Analysis}
\begin{verbatim}
def process_data(data):
    if len(data) <= 1:
        return dict(data)
    mid = len(data) // 2
    left = process_data(data[:mid])
    right = process_data(data[mid:])
    for key in right:
        left[key] = right[key]
    return left
\end{verbatim}
\textbf{Recurrence:} \underline{\hspace{10cm}} \\
\textbf{Question:} Based on how the array is divided and how long the combine step takes, write a recurrence for the running time of this function.

\vspace{2em}

\section*{Problem 10: Counting Sort Example}
\begin{verbatim}
arr = [4, 2, 2, 8, 3, 3, 1]
\end{verbatim}
\textbf{Question:} Show how counting sort would sort this list step by step. What is the running time of counting sort in terms of $n$ (length of the array) and $k$ (maximum key value)? What assumptions must be true about the input data for counting sort to be efficient?

\vspace{2em}

\section*{Problem 11: When to Use Counting Sort}
\begin{verbatim}
arr = [15, 14, 16, 14, 15]
\end{verbatim}
\textbf{Question:} Can counting sort be used efficiently on this input? What is the running time in terms of $n$ and $k$? What assumptions about the data must hold for counting sort to be efficient?

\vspace{2em}

\section*{Problem 12: Radix Sort on Strings}
\begin{verbatim}
arr = ['bca', 'cab', 'abc', 'acb']
\end{verbatim}
\textbf{Question:} Show the steps radix sort would follow when sorting this list of 3-letter strings. What is the running time of radix sort in terms of $n$ (number of strings) and $d$ (number of characters per string)? What assumptions must be true about the input for radix sort to be efficient?

\vspace{2em}

\section*{Problem 13: Bucket Sort on Decimals}
\begin{verbatim}
arr = [0.13, 0.25, 0.22, 0.45, 0.21, 0.24]
\end{verbatim}
\textbf{Question:} Show how bucket sort would process this list. What is the running time of bucket sort in terms of $n$? What assumptions about the distribution of input data must hold for bucket sort to be efficient?

\vspace{2em}

\section*{Problem 14: Counting Sort - Characters}
\begin{verbatim}
arr = ['d', 'a', 'c', 'b', 'a']
\end{verbatim}
\textbf{Question:} Show how counting sort would sort this list of lowercase letters assuming they are converted to ASCII codes. What is the running time in terms of $n$ (number of characters) and $k$ (range of ASCII codes)? What assumptions must be true for counting sort to be efficient?

\vspace{2em}

\section*{Problem 15: When Not to Use Counting Sort}
\begin{verbatim}
arr = [100, 50000, 30000, 20000]
\end{verbatim}
\textbf{Question:} Explain why counting sort is a poor choice for this input. What would $k$ be and how does it affect the running time? What assumptions about the input data make counting sort inefficient in this case?

\vspace{2em}

\section*{Problem 16: Radix Sort - Integers}
\begin{verbatim}
arr = [329, 457, 657, 839, 436, 720, 355]
\end{verbatim}
\textbf{Question:} Show how radix sort processes this list of integers. What is the running time in terms of $n$ (number of integers) and $d$ (number of digits)? What assumptions must be true about the input for radix sort to be efficient?

\vspace{2em}

\section*{Problem 17: Bucket Sort - Uniform Input}
\begin{verbatim}
arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]
\end{verbatim}
\textbf{Question:} Perform bucket sort on this input. What is the running time in terms of $n$? How does the uniform distribution of the input values over [0,1) affect the efficiency of bucket sort? What assumptions must hold for bucket sort to be efficient?

\vspace{2em}


\section*{Problem 18: Why Comparison-Based Sorting is $\Omega(n \log n)$}
\textbf{Question:} Explain why any sorting algorithm that uses only comparisons must take at least $\Omega(n \log n)$ time in the worst case. Use the concept of decision trees in your explanation.

\vspace{2em}

\section*{Problem 19: Sorting Lower Bound Application}
\textbf{Question:} Suppose you are designing a new sorting algorithm that only compares elements and does not use any assumptions about the input. Can this algorithm ever beat the $\Omega(n \log n)$ lower bound? Justify your answer.

\end{document}
